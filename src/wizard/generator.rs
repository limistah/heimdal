use anyhow::Result;
use chrono::Local;
use std::collections::HashMap;
use std::path::Path;

use super::package_detector::{DetectedPackage, PackageManager};
use super::scanner::ScannedDotfile;

/// Generator for creating heimdal.yaml configuration files
pub struct ConfigGenerator {
    profile_name: String,
    repo_url: Option<String>,
    dotfiles: Vec<String>,
    packages: HashMap<String, Vec<String>>,
    stow_compat: bool,
}

impl ConfigGenerator {
    /// Create a new config generator
    pub fn new(profile_name: &str) -> Self {
        Self {
            profile_name: profile_name.to_string(),
            repo_url: None,
            dotfiles: Vec::new(),
            packages: HashMap::new(),
            stow_compat: true,
        }
    }

    /// Set the Git repository URL
    pub fn with_repo_url(mut self, url: String) -> Self {
        self.repo_url = Some(url);
        self
    }

    /// Set whether to use Stow compatibility mode
    pub fn with_stow_compat(mut self, enabled: bool) -> Self {
        self.stow_compat = enabled;
        self
    }

    /// Add dotfiles to track
    pub fn add_dotfiles(&mut self, dotfiles: Vec<ScannedDotfile>) {
        self.dotfiles = dotfiles.iter().map(|d| d.relative_path.clone()).collect();
    }

    /// Add packages to track
    pub fn add_packages(&mut self, packages: Vec<DetectedPackage>) {
        // Group packages by manager
        for package in packages {
            let manager_key = match package.manager {
                PackageManager::Homebrew => {
                    if package.name.starts_with("--cask ") {
                        "homebrew_casks"
                    } else {
                        "homebrew"
                    }
                }
                PackageManager::Apt => "apt",
                PackageManager::Dnf => "dnf",
                PackageManager::Pacman => "pacman",
                PackageManager::Mas => "mas",
            };

            self.packages
                .entry(manager_key.to_string())
                .or_insert_with(Vec::new)
                .push(package.name.clone());
        }
    }

    /// Generate the YAML configuration
    pub fn generate(&self) -> Result<String> {
        let mut yaml = String::new();

        // Header comment
        yaml.push_str("# Heimdal Configuration\n");
        yaml.push_str(&format!("# Generated by: heimdal wizard\n"));
        yaml.push_str(&format!(
            "# Date: {}\n",
            Local::now().format("%Y-%m-%d %H:%M:%S")
        ));
        yaml.push_str("\n");

        // Heimdal section
        yaml.push_str("heimdal:\n");
        yaml.push_str("  version: \"1.0\"\n");

        if let Some(ref repo) = self.repo_url {
            yaml.push_str(&format!("  repo: \"{}\"\n", repo));
        } else {
            yaml.push_str("  # repo: \"git@github.com:username/dotfiles.git\"\n");
        }

        yaml.push_str(&format!("  stow_compat: {}\n", self.stow_compat));
        yaml.push_str("\n");

        // Global ignore patterns
        yaml.push_str("# Files to ignore when symlinking\n");
        yaml.push_str("ignore:\n");
        yaml.push_str("  - .git\n");
        yaml.push_str("  - .gitignore\n");
        yaml.push_str("  - heimdal.yaml\n");
        yaml.push_str("  - README.md\n");
        yaml.push_str("  - .DS_Store\n");
        yaml.push_str("\n");

        // Sources section
        if !self.packages.is_empty() {
            yaml.push_str("# Package sources\n");
            yaml.push_str("sources:\n");

            // Common packages (cross-platform)
            if let Some(packages) = self.get_common_packages() {
                if !packages.is_empty() {
                    yaml.push_str("  # Cross-platform packages (auto-mapped)\n");
                    yaml.push_str("  packages:\n");
                    for pkg in packages {
                        yaml.push_str(&format!("    - {}\n", pkg));
                    }
                    yaml.push_str("\n");
                }
            }

            // Homebrew
            if let Some(brew_packages) = self.packages.get("homebrew") {
                yaml.push_str("  # Homebrew packages (macOS)\n");
                yaml.push_str("  homebrew:\n");
                yaml.push_str("    packages:\n");
                for pkg in brew_packages {
                    yaml.push_str(&format!("      - {}\n", pkg));
                }
                yaml.push_str("\n");
            }

            // Homebrew casks
            if let Some(cask_packages) = self.packages.get("homebrew_casks") {
                yaml.push_str("  # Homebrew casks (macOS applications)\n");
                yaml.push_str("  homebrew_casks:\n");
                yaml.push_str("    casks:\n");
                for pkg in cask_packages {
                    let cask_name = pkg.trim_start_matches("--cask ").trim();
                    yaml.push_str(&format!("      - {}\n", cask_name));
                }
                yaml.push_str("\n");
            }

            // APT
            if let Some(apt_packages) = self.packages.get("apt") {
                yaml.push_str("  # APT packages (Debian/Ubuntu)\n");
                yaml.push_str("  apt:\n");
                yaml.push_str("    packages:\n");
                for pkg in apt_packages {
                    yaml.push_str(&format!("      - {}\n", pkg));
                }
                yaml.push_str("\n");
            }

            // DNF
            if let Some(dnf_packages) = self.packages.get("dnf") {
                yaml.push_str("  # DNF packages (Fedora/RHEL)\n");
                yaml.push_str("  dnf:\n");
                yaml.push_str("    packages:\n");
                for pkg in dnf_packages {
                    yaml.push_str(&format!("      - {}\n", pkg));
                }
                yaml.push_str("\n");
            }

            // Pacman
            if let Some(pacman_packages) = self.packages.get("pacman") {
                yaml.push_str("  # Pacman packages (Arch Linux)\n");
                yaml.push_str("  pacman:\n");
                yaml.push_str("    packages:\n");
                for pkg in pacman_packages {
                    yaml.push_str(&format!("      - {}\n", pkg));
                }
                yaml.push_str("\n");
            }

            // Mac App Store
            if let Some(mas_packages) = self.packages.get("mas") {
                yaml.push_str("  # Mac App Store apps\n");
                yaml.push_str("  mas:\n");
                yaml.push_str("    packages:\n");
                for pkg in mas_packages {
                    yaml.push_str(&format!("      - name: \"{}\"\n", pkg));
                }
                yaml.push_str("\n");
            }
        }

        // Profiles section
        yaml.push_str("# Machine profiles\n");
        yaml.push_str("profiles:\n");
        yaml.push_str(&format!("  {}:\n", self.profile_name));

        // Add sources to profile
        if !self.packages.is_empty() {
            yaml.push_str("    sources:\n");

            if self.get_common_packages().is_some() {
                yaml.push_str("      - packages\n");
            }

            for manager in &["homebrew", "homebrew_casks", "apt", "dnf", "pacman", "mas"] {
                if self.packages.contains_key(*manager) {
                    yaml.push_str(&format!("      - {}\n", manager));
                }
            }
            yaml.push_str("\n");
        }

        // Dotfiles configuration
        if !self.dotfiles.is_empty() {
            yaml.push_str("    # Dotfiles configuration\n");
            yaml.push_str("    dotfiles:\n");

            if self.stow_compat {
                yaml.push_str("      use_stowrc: true\n");
                yaml.push_str("      # Files will be symlinked according to .stowrc\n");
            } else {
                yaml.push_str("      symlink_all: true\n");
                yaml.push_str("      # All files in dotfiles directory will be symlinked\n");
            }
        }

        Ok(yaml)
    }

    /// Get common packages that should be in the cross-platform section
    fn get_common_packages(&self) -> Option<Vec<String>> {
        let common_tools = vec![
            "git", "vim", "neovim", "tmux", "curl", "wget", "tree", "fzf", "ripgrep", "bat", "fd",
            "jq", "htop",
        ];

        let mut common = Vec::new();

        // Check all package managers for common tools
        for manager_packages in self.packages.values() {
            for pkg in manager_packages {
                let pkg_lower = pkg.to_lowercase();
                for tool in &common_tools {
                    if pkg_lower.contains(tool) && !common.contains(&pkg.to_string()) {
                        common.push(pkg.clone());
                    }
                }
            }
        }

        if common.is_empty() {
            None
        } else {
            common.sort();
            Some(common)
        }
    }

    /// Save the configuration to a file
    pub fn save(&self, path: impl AsRef<Path>) -> Result<()> {
        let yaml = self.generate()?;
        std::fs::write(path, yaml)?;
        Ok(())
    }

    /// Get a preview of the configuration (first N lines)
    pub fn preview(&self, lines: usize) -> Result<String> {
        let yaml = self.generate()?;
        let preview: Vec<&str> = yaml.lines().take(lines).collect();
        Ok(preview.join("\n"))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::wizard::package_detector::PackageCategory;

    #[test]
    fn test_generate_minimal() {
        let generator = ConfigGenerator::new("personal");
        let yaml = generator.generate().unwrap();

        assert!(yaml.contains("heimdal:"));
        assert!(yaml.contains("version: \"1.0\""));
        assert!(yaml.contains("profiles:"));
        assert!(yaml.contains("personal:"));
    }

    #[test]
    fn test_generate_with_repo() {
        let generator = ConfigGenerator::new("work")
            .with_repo_url("git@github.com:user/dotfiles.git".to_string());
        let yaml = generator.generate().unwrap();

        assert!(yaml.contains("repo: \"git@github.com:user/dotfiles.git\""));
    }

    #[test]
    fn test_generate_with_packages() {
        let mut generator = ConfigGenerator::new("personal");

        let packages = vec![
            DetectedPackage {
                name: "git".to_string(),
                manager: PackageManager::Homebrew,
                category: PackageCategory::Essential,
            },
            DetectedPackage {
                name: "vim".to_string(),
                manager: PackageManager::Homebrew,
                category: PackageCategory::Essential,
            },
        ];

        generator.add_packages(packages);
        let yaml = generator.generate().unwrap();

        assert!(yaml.contains("sources:"));
        assert!(yaml.contains("homebrew:"));
        assert!(yaml.contains("- git"));
        assert!(yaml.contains("- vim"));
    }

    #[test]
    fn test_preview() {
        let generator = ConfigGenerator::new("personal");
        let preview = generator.preview(5).unwrap();

        let lines: Vec<&str> = preview.lines().collect();
        assert_eq!(lines.len(), 5);
        assert!(lines[0].starts_with("# Heimdal Configuration"));
    }
}
